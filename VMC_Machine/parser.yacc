open DataTypes;
val lst = ref ["#"];
val temp = ref BOOLEAN;
val temp2 = ref SymbolTable.BOOLEAN;
fun getType(x:string) = case HashTable.find SymbolTable.htable x of SOME (ind,typ) =>  
							if typ = SymbolTable.BOOLEAN then (temp:=BOOLEAN) else (temp:=INTEGER)
							| NONE => (print ("Variable:"^x^" is being used before declaration\n"); HashTable.clear SymbolTable.htable; lst:=[]; raise SymbolTable.IdentifierNotDeclared);


%%


%name WHILEEXP

%pos int

%term
NUMERAL of int | LPAREN | RPAREN | LBRACE | RBRACE | SEQ | VAR | COLON | DOUBLECOLON | INT | BOOL | IF | ELSE | ENDIF | WHILE | DO | ENDWH | OR | AND | TT | FF | NOT | LT | LEQ | EQ | GT | GEQ | NEQ | PLUS | MINUS | DIV | MOD | TIMES | TILDE | SET | EOF | PROG | COMMA | THEN | READ | WRITE | IDENTIFIER of string 
%nonterm 

PROGRAM of AST | DECLARATIONSEQ of DEC | DECLARATION of DEC | VARLIST of VARIABLELIST  | COMMANDSEQ of CMD| COMMANDLIST of CMD| COMMAND of CMD | EXPRESSION of EXP 


%start PROGRAM

%eop EOF 
%left OR
%left AND
%left LT LEQ EQ GT GEQ NEQ 
%left MINUS PLUS
%left TIMES DIV MOD
%right TILDE NOT

%noshift EOF
%arg (fileName) : string
%verbose

%%



PROGRAM : PROG IDENTIFIER DOUBLECOLON DECLARATIONSEQ COMMANDSEQ(PROG(IDENTIFIER, DECLARATIONSEQ,COMMANDSEQ)) |  PROG IDENTIFIER DOUBLECOLON COMMANDSEQ (PROG(IDENTIFIER,EMPTYDEC,COMMANDSEQ))
DECLARATIONSEQ : DECLARATION (DECLARATION) | DECLARATION DECLARATIONSEQ (DSEQ (DECLARATION, DECLARATIONSEQ))
DECLARATION : VAR IDENTIFIER VARLIST (lst:=IDENTIFIER::(!lst);SymbolTable.insertListInTable(!lst,!temp2);lst:=[];DEC(IDENTIFIER,VARLIST))
VARLIST : COLON INT SEQ	(lst:=[];temp2:=SymbolTable.INTEGER;INTLIST)
		| COLON BOOL SEQ   (lst:=[];temp2:=SymbolTable.BOOLEAN;BOOLLIST)	
		| COMMA IDENTIFIER VARLIST  (lst:=IDENTIFIER::(!lst);COMMA(IDENTIFIER,VARLIST))

COMMANDSEQ : LBRACE RBRACE (EMPTYCMD)
			| LBRACE COMMANDLIST RBRACE (COMMANDLIST)
COMMANDLIST : COMMAND SEQ (COMMAND)
			| COMMAND SEQ COMMANDLIST (CSEQ(COMMAND,COMMANDLIST))
COMMAND : IDENTIFIER SET EXPRESSION (getType(IDENTIFIER);SET(IDENTIFIER,EXPRESSION,!temp))
		| READ IDENTIFIER (getType(IDENTIFIER);READ(IDENTIFIER,!temp))
		| WRITE EXPRESSION (WRITE(EXPRESSION))
		| IF EXPRESSION THEN COMMANDSEQ ELSE COMMANDSEQ ENDIF (ITE(EXPRESSION,COMMANDSEQ1,COMMANDSEQ2))
		| WHILE EXPRESSION DO COMMANDSEQ ENDWH(WH(EXPRESSION,COMMANDSEQ))


EXPRESSION : EXPRESSION PLUS EXPRESSION(PLUS(EXPRESSION1,EXPRESSION2))
			| EXPRESSION MINUS EXPRESSION(MINUS(EXPRESSION1,EXPRESSION2))
			| EXPRESSION TIMES EXPRESSION(TIMES(EXPRESSION1,EXPRESSION2))
			| EXPRESSION DIV EXPRESSION (DIV(EXPRESSION1,EXPRESSION2))
			| EXPRESSION MOD EXPRESSION (MOD(EXPRESSION1,EXPRESSION2))
			| NUMERAL (INT(NUMERAL))
			| PLUS NUMERAL (UNPLUS(NUMERAL))
			| IDENTIFIER(getType(IDENTIFIER);VARIABLE(IDENTIFIER,!temp))
			| TT(TT)
			| FF(FF)
			| EXPRESSION LT EXPRESSION(LT(EXPRESSION1,EXPRESSION2))
			| EXPRESSION LEQ EXPRESSION(LEQ(EXPRESSION1,EXPRESSION2))
			| EXPRESSION EQ EXPRESSION (EQ(EXPRESSION1,EXPRESSION2))
			| EXPRESSION GT EXPRESSION (GT(EXPRESSION1,EXPRESSION2))
			| EXPRESSION GEQ EXPRESSION (GEQ(EXPRESSION1,EXPRESSION2))
			| EXPRESSION NEQ EXPRESSION (NEQ(EXPRESSION1,EXPRESSION2))
			| EXPRESSION OR EXPRESSION (OR(EXPRESSION1,EXPRESSION2))
			| EXPRESSION AND EXPRESSION (AND(EXPRESSION1,EXPRESSION2))
			| NOT EXPRESSION (NOT(EXPRESSION))
			| LPAREN EXPRESSION RPAREN (EXPRESSION)
			| TILDE EXPRESSION (TILDE(EXPRESSION))




			


